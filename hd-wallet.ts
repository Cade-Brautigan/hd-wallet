import * as bip39 from '@scure/bip39'
import { wordlist as EnglishWordlist } from '@scure/bip39/wordlists/english';

import { HDKey as BIP32HDKey } from "@scure/bip32";
import { HDKey as SLIP0010HDKey } from "micro-ed25519-hdkey";

import { Keypair } from '@solana/web3.js'
import { Wallet } from 'ethers'
import * as bitcoin from 'bitcoinjs-lib'
import * as tinysecp from 'tiny-secp256k1';
import { ECPairFactory, ECPairAPI, ECPairInterface } from 'ecpair';

export class InvalidMnemonicWordCountError extends Error {
    constructor() {
        super("Invalid mnemonic: The mnemonic must contain exactly 12 words.");
        this.name = "InvalidWordCountError";
    }
}

export class InvalidMnemonicWordsError extends Error {
    constructor(invalidWords: string[]) {
        super(`Invalid mnemonic: The following words are not valid: ${invalidWords.join(', ')}`);
        this.name = "InvalidMnemonicWordsError";
    }
}

export class MissingPrivateKeyError extends Error {
    constructor() {
        super("Invalid BIP32Interface object: Private key missing");
        this.name = "MissingPrivateKeyError"
    }
}

// MASTER SEED GENERATION

/**
 * Convert a 12 word English mnemmonic into a 64 byte master seed as defined in BIP-39
 *
 * @param {string} mneumonic A 12 word English mnemonic phrase
 * @returns {Uint8Array} The 64 byte seed
 */
export const mnemonicToBIP39MasterSeed = (mnemonic: string): Uint8Array => {
    // Split the mnemonic into words and check if it has exactly 12 words
    const words = mnemonic.trim().split(/\s+/);
    if (words.length !== 12) {
        throw new InvalidMnemonicWordCountError();
    }

    // Validate that each word is in the BIP39 English word list
    const invalidWords = words.filter(word => !EnglishWordlist.includes(word));
    if (invalidWords.length > 0) {
        throw new InvalidMnemonicWordsError(invalidWords);
    }
    
    // Generate the seed
    return bip39.mnemonicToSeedSync(mnemonic); // 64 bytes
}



// MASTER KEY GENERATION

/**
 * Generate a BIP-32 master key from the BIP-39 master seed for further secp256k1-based keypair derivations (i.e. Bitcoin, Ethereum)
 * 
 * @param {Uint8Array} masterSeed The 64 byte master seed generated by converting a BIP39 mnemonic to BIP39 seed
 * @returns {BIP32HDKey} The @scure.bip32 object containing the master key
 */
export const masterSeedToBIP32MasterKey = (masterSeed: Uint8Array): BIP32HDKey => {
    if (masterSeed.length != 64) {
        throw new Error("Seed must be 64 bytes in length");
    }

    return BIP32HDKey.fromMasterSeed(masterSeed);
}

/**
 * Generate a SLIP-0010 master key from the master seed for further ed25519-based keypair derivations (i.e. Solana)
 * 
 * @param {Uint8Array} masterSeed The 64 byte master seed generated by converting a BIP39 mnemonic to BIP39 seed
 * @returns {SLIP0010HDKey} The @scure.bip32 object containing the master key
 */
export const masterSeedToSLIP0010MasterKey = (masterSeed: Uint8Array): SLIP0010HDKey => {
    if (masterSeed.length != 64) {
        throw new Error("Seed must be 64 bytes in length");
    }

    const masterSeedHex: string = Array.from(masterSeed)
        .map(byte => byte.toString(16).padStart(2, '0'))
        .join('');

    return SLIP0010HDKey.fromMasterSeed(masterSeedHex);
}



// NETWORK-SPECIFIC KEYPAIR DERIVATIONS

/**
 * Return an ethers Wallet from a BIP-32 master key
 *
 * @param {BIP32HDKey} bip32masterKey The BIP-32 master key
 * @param {number} index - The account number
 * @returns {Wallet} The ethers Wallet object
 */
export const deriveEvmKeypair = (bip32masterKey: BIP32HDKey, index: number): Wallet => {
    const bip32node: BIP32HDKey = bip32masterKey.derive(`m/44'/60'/0'/0/${index}`);

    if (bip32node.privateKey) {
        const privateKeyHex = Array.from(bip32node.privateKey)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
    
        return new Wallet(privateKeyHex);
    } else {
        throw new MissingPrivateKeyError();
    }
};

/**
 * Return a Solana Keypair from a SLIP-0010 master key
 *
 * @param {SLIP0010HDKey} slip0010masterKey The master key for all
 * @param {number} index - The account number 
 * @returns {Keypair} The solana/web3.js object
 */
export const deriveSolanaKeypair = (slip0010masterKey: SLIP0010HDKey, index: number = 0): Keypair => {
    const slip0010node: SLIP0010HDKey = slip0010masterKey.derive(`m/44'/501'/${index}'/0'`);

    if (slip0010node.privateKey) {
        return Keypair.fromSeed(slip0010node.privateKey);
    } else {
        throw new MissingPrivateKeyError();
    }
}

/**
 * Return a ECPairInterface object with Segwit Bitcoin keypair from a BIP32HDKey master key
 *
 * @param {BIP32HDKey} master - The master key object
 * @param {number} index - The account number
 * @returns {ECPairInterface} The bitcoinjs-lib object
 * @throws {MissingPrivateKeyError} If the derived node lacks a private key
 */
export const deriveBitcoinSegwitKeypair = (bip32masterKey: BIP32HDKey, index: number = 0): ECPairInterface => {
    const btcNode: BIP32HDKey = bip32masterKey.derive(`m/84'/0'/0'/0/${index}`); // Native SegWit (Bech32)

    if (btcNode.privateKey) {
        const ECPair: ECPairAPI = ECPairFactory(tinysecp);
        return ECPair.fromPrivateKey(btcNode.privateKey);
    } else {
        throw new MissingPrivateKeyError();
    }

}

/**
 * Return a ECPairInterface object with Taproot Bitcoin keypair from a BIP32HDKey master key
 *
 * @param {BIP32HDKey} master - The master key object
 * @param {number} index - The account number
 * @returns {ECPairInterface} The bitcoinjs-lib object
 * @throws {MissingPrivateKeyError} If the derived node lacks a private key
 */
export const deriveBitcoinTaprootKeypair = (bip32masterKey: BIP32HDKey, index: number = 0): ECPairInterface => {
    const btcNode: BIP32HDKey = bip32masterKey.derive(`m/86'/0'/0'/0/${index}`); // Taproot (Bech32m)

    if (btcNode.privateKey) {
        const ECPair: ECPairAPI = ECPairFactory(tinysecp);
        return ECPair.fromPrivateKey(btcNode.privateKey);
    } else {
        throw new MissingPrivateKeyError();
    }
    
}

/**
 * Converts a public key to a Bitcoin SegWit address using Bech32 encoding
 * 
 * @param {Uint8Array} publicKey - The public key to encode
 * @returns {string} A Bech32-encoded Bitcoin address starting with 'bc1q'
 * @throws {Error} If address generation fails
 */
export const toSegwitBech32 = (publicKey: Uint8Array): string => {
    const { address } = bitcoin.payments.p2wpkh({
        pubkey: publicKey,
        network: bitcoin.networks.bitcoin, // Use bitcoin.networks.testnet for testnet
    });
    if (!address) throw new Error('Failed to generate Bech32 address');
    return address;
};

/**
 * Converts a public key to a Bitcoin Taproot address using Bech32m encoding
 * 
 * @param {Uint8Array} publicKey - The public key to encode (first byte will be sliced off)
 * @returns {string} A Bech32m-encoded Bitcoin address starting with 'bc1p'
 * @throws {Error} If address generation fails
 */
export const toTaprootBech32m = (publicKey: Uint8Array): string => {
    bitcoin.initEccLib(tinysecp);
    const { address } = bitcoin.payments.p2tr({
        pubkey: publicKey.slice(1), // Remove the first byte (key type prefix)
        network: bitcoin.networks.bitcoin, // Use bitcoin.networks.testnet for testnet
    });
    if (!address) throw new Error('Failed to generate Bech32m address');
    return address;
};



(async () => {
    const mnemonic: string = bip39.generateMnemonic(EnglishWordlist, 128); // 12 words
    const masterSeed: Uint8Array = mnemonicToBIP39MasterSeed(mnemonic);

    const bip39masterKey: BIP32HDKey = masterSeedToBIP32MasterKey(masterSeed);
    const slip0010masterKey: SLIP0010HDKey = masterSeedToSLIP0010MasterKey(masterSeed);

    const evmKeypair: Wallet = deriveEvmKeypair(bip39masterKey, 0);
    const solanaKeypair: Keypair = deriveSolanaKeypair(slip0010masterKey, 0);
    const bitcoinSegwitKeypair: ECPairInterface = deriveBitcoinSegwitKeypair(bip39masterKey, 0);
    const bitcoinTaprootKeypair: ECPairInterface = deriveBitcoinTaprootKeypair(bip39masterKey, 0)

    console.log("EVM address:", evmKeypair.address);
    console.log("Solana address:", solanaKeypair.publicKey.toBase58());
    console.log("Bitcoin native segwit address:", toSegwitBech32(bitcoinSegwitKeypair.publicKey));
    console.log("Bitcoin taproot address:", toTaprootBech32m(bitcoinTaprootKeypair.publicKey));
})();

// TODO Make network of addresses customizable (mainnet, testnet)